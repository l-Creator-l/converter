import { app, BrowserWindow, ipcMain } from 'electron';
import * as fs from 'fs';
import * as fsPromises from 'fs/promises';
import * as path from 'path';
import { IData } from './Types/electronTypes';
import { IForm, IOrganization } from './Types/reduxTypes';
import xmlGenerator from './Functions/xmlGenerator';
import fixRegion from './Functions/fixRegion';
import getAdditionalKey from './Functions/getAdditionalKey';

const excelToJson = require('convert-excel-to-json');
const dayjs = require('dayjs');

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
	app.quit();
}

const createWindow = (): void => {
	// Create the browser window.
	const mainWindow = new BrowserWindow({
		show: false,
		autoHideMenuBar: true,
		center: true,
        icon: __dirname + 'Icon/icon.ico',
		webPreferences: {
			preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
		},
	});

	mainWindow.maximize();
	mainWindow.show();

	// and load the index.html of the app.
	mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

	// Open the DevTools.
	//mainWindow.webContents.openDevTools();
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {

	ipcMain.handle('transferData', async (event, data:IData) => {

		try {

			const jsonArray = [];
			const xmlArray = [];
            const notFound = [];
			const dir = await fsPromises.readdir(data.path);
            let resultDirError = '';

            if (!fs.existsSync(data.path + '\\Result')) {
                fs.mkdir(data.path + '\\Result', (error) => {
                    if (error) resultDirError = 'При создании папки Result возникла ошибка';
                });
            }
            else resultDirError = `Папка с именем Result уже существует в указанном каталоге "${data.path}"`;

            if (resultDirError) return { success: 0, error: resultDirError };

			for (const file of dir) {

				const stat = await fsPromises.stat(`${data.path}\\${file}`);

				if (stat.isDirectory() || !/\.xlsx$/i.test(file) || !file.match(/^\d+_(\d+ ?- ?[а-яё]+( [а-яё]+)*)/i) || !file.match(/_[а-яё -]*(\d{4})_/i) || !file.match(/^(\d{12})_/)) continue;

				const json = excelToJson({ sourceFile: path.join(data.path, file) });

                let unp = '';

				for (const sheet in json) {
                    if (/титульный/i.test(sheet) && (json[sheet].length >= 14) && ('G' in json[sheet][14])) unp = json[sheet][14]['G'];
					if (!/таблица ?\d+/i.test(sheet)) delete json[sheet];
					else {
						let rowCounter = 0;
						for (const row of json[sheet]) {
						    const string = Object.values(row).join('');
							rowCounter++;
							if (/^[а-яё]+\d+$/gi.test(string)) {
								json[sheet].splice(0, rowCounter);
								break;
							}
						}
							
						json[sheet].forEach((row:any) => {delete row.B});

					}
				}

				jsonArray.push({
                    fileName: file,
                    unp,
                    tables: Object.values(json)
                });
				
			}

            if (!jsonArray.length) return { success: 0, error: `Не удалось обнаружить подходящие файлы формата xlsx в указанном каталоге ${data.path}` };

			for (const file of jsonArray) {

                const formName = file.fileName.match(/^\d+_(\d+ ?- ?[а-яё]+( [а-яё]+)*)/i)[1];
                const formYear = file.fileName.match(/_[а-яё -]*(\d{4})_/i)[1];
                const organizationOKPO = file.fileName.match(/^(\d{12})_/)[1];
                let dbForm:IForm;
                let dbFormNumber:number;
                let dbOrganization:IOrganization;
                let okpo;
                let region;

                data.forms.forEach((item, i) => {
                    if ((item.name === formName) && (item.year == formYear)) {
                        dbForm = item;
                        dbFormNumber = i;
                    }
                });
                data.organizations.forEach(item => {
                    if (item.okpoBad === organizationOKPO) dbOrganization = item;
                });

                if (!dbForm) {
                    notFound.push(file.fileName);
                    continue;
                }

                if (dbOrganization) {
                    okpo = dbOrganization.okpoGood.slice(0, 8) + dbOrganization.okpoGood.slice(9);
                    region = fixRegion(dbOrganization.okpoGood.slice(8, 9));
                }
                else {
                    okpo = organizationOKPO.slice(0, 8) + organizationOKPO.slice(9);
                    region = fixRegion(organizationOKPO.slice(8, 9));
                }

                xmlArray.push({
                    form: dbForm,
                    okpo,
                    unp: file.unp,
                    region,
                    fileName: file.fileName,
                    xml: xmlGenerator(file, dbForm, dbFormNumber, okpo, data.rules)
                })
			}

            switch(data.group) {

                case 'by forms':
                    for (const item of xmlArray) {

                        const additionalKey = getAdditionalKey(item.form.name, item.fileName) ? `_${getAdditionalKey(item.form.name, item.fileName)}` : '';

                        if (!fs.existsSync(`${data.path}\\Result\\${item.form.name}`)) fs.mkdirSync(`${data.path}\\Result\\${item.form.name}`);
                        if (!fs.existsSync(`${data.path}\\Result\\${item.form.name}\\${item.region}`)) fs.mkdirSync(`${data.path}\\Result\\${item.form.name}\\${item.region}`);
                        await fsPromises.writeFile(`${data.path}\\Result\\${item.form.name}\\${item.region}\\999_${item.form.code}_${item.form.year}_${/здрав$/i.test(item.form.name) ? item.unp : item.okpo}${additionalKey}__${dayjs().format('YYYYMMDD')}.xml`, item.xml);

                    }
                break;

                case 'by organizations':
                    for (const item of xmlArray) {

                        const additionalKey = getAdditionalKey(item.form.name, item.fileName) ? `_${getAdditionalKey(item.form.name, item.fileName)}` : '';

                        if (!fs.existsSync(`${data.path}\\Result\\${item.okpo}`)) fs.mkdirSync(`${data.path}\\Result\\${item.okpo}`);
                        if (!fs.existsSync(`${data.path}\\Result\\${item.okpo}\\${item.form.name}`)) fs.mkdirSync(`${data.path}\\Result\\${item.okpo}\\${item.form.name}`);
                        if (!fs.existsSync(`${data.path}\\Result\\${item.okpo}\\${item.form.name}\\${item.region}`)) fs.mkdirSync(`${data.path}\\Result\\${item.okpo}\\${item.form.name}\\${item.region}`);
                        await fsPromises.writeFile(`${data.path}\\Result\\${item.okpo}\\${item.form.name}\\${item.region}\\999_${item.form.code}_${item.form.year}_${/здрав$/i.test(item.form.name) ? item.unp : item.okpo}${additionalKey}__${dayjs().format('YYYYMMDD')}.xml`, item.xml);
                    
                    }
                break;

                case 'do not group':
                    for (const item of xmlArray) {

                        const additionalKey = getAdditionalKey(item.form.name, item.fileName) ? `_${getAdditionalKey(item.form.name, item.fileName)}` : '';

                        await fsPromises.writeFile(`${data.path}\\Result\\999_${item.form.code}_${item.form.year}_${/здрав$/i.test(item.form.name) ? item.unp : item.okpo}${additionalKey}__${dayjs().format('YYYYMMDD')}.xml`, item.xml);

                    }
                break;

            }

			return { success: xmlArray.length, notFound };

		}
		catch (error) {
			return { success: 0, error: error.message };
		}

	});

    ipcMain.handle('getVersion', async () => {
        return app.getVersion();
    });

	createWindow();

});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
	if (process.platform !== 'darwin') {
		app.quit();
	}
});

app.on('activate', () => {
	// On OS X it's common to re-create a window in the app when the
	// dock icon is clicked and there are no other windows open.
	if (BrowserWindow.getAllWindows().length === 0) {
		createWindow();
	}
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.